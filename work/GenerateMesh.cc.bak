#include <gmsh.h>

#include <iostream>
#include <vector>

int generate_mesh(std::vector<double>& nodeCoord,
                  std::vector<size_t>& elementNodeTags, double L, double B,
                  double a, double b, double lc, bool isSerendipity = true,
                  int meshAlgorithm = 8) {
    // Initialize the Gmsh library
    gmsh::initialize();
    gmsh::option::setNumber("General.Terminal", 0);
    try {
        // Start a new model
        gmsh::model::add("RectangleWithHole");

        // Outer rectangle points
        std::vector<int> pointsTag;
        pointsTag.push_back(gmsh::model::geo::addPoint(-L / 2, -B / 2, 0, lc));
        pointsTag.push_back(gmsh::model::geo::addPoint(L / 2, -B / 2, 0, lc));
        pointsTag.push_back(gmsh::model::geo::addPoint(L / 2, B / 2, 0, lc));
        pointsTag.push_back(gmsh::model::geo::addPoint(-L / 2, B / 2, 0, lc));

        // Outer rectangle lines
        std::vector<int> linesTag(4);
        for (int i = 0; i < linesTag.size(); ++i) {
            linesTag[i] =
                gmsh::model::geo::addLine(pointsTag[i], pointsTag[(i + 1) % 4]);
        }

        // Outer loop (line loop)
        int rectangleCurveLoopTag = gmsh::model::geo::addCurveLoop(linesTag);

        // Add center point
        int centerTag = gmsh::model::geo::addPoint(0, 0, 0, lc);

        // Add major and minor axis points
        int majorAxisEnd1Tag = gmsh::model::geo::addPoint(a, 0, 0, lc);
        int majorAxisEnd2Tag = gmsh::model::geo::addPoint(-a, 0, 0, lc);
        int minorAxisEnd1Tag = gmsh::model::geo::addPoint(0, b, 0, lc);
        int minorAxisEnd2Tag = gmsh::model::geo::addPoint(0, -b, 0, lc);

        // Define the first and second half of the ellipse
        int ellipseArc1Tag = gmsh::model::geo::addEllipseArc(
            majorAxisEnd1Tag, centerTag, majorAxisEnd1Tag, minorAxisEnd1Tag);
        int ellipseArc2Tag = gmsh::model::geo::addEllipseArc(
            minorAxisEnd1Tag, centerTag, majorAxisEnd2Tag, majorAxisEnd2Tag);
        int ellipseArc3Tag = gmsh::model::geo::addEllipseArc(
            majorAxisEnd2Tag, centerTag, majorAxisEnd2Tag, minorAxisEnd2Tag);
        int ellipseArc4Tag = gmsh::model::geo::addEllipseArc(
            minorAxisEnd2Tag, centerTag, majorAxisEnd1Tag, majorAxisEnd1Tag);

        // Create a curve loop and plane surface
        int ellipseCurveLoopTag = gmsh::model::geo::addCurveLoop(
            {ellipseArc1Tag, ellipseArc2Tag, ellipseArc3Tag, ellipseArc4Tag});

        // Plane surface with inclusion
        gmsh::model::geo::addPlaneSurface(
            {rectangleCurveLoopTag, ellipseCurveLoopTag}, 1);

        gmsh::model::geo::addPlaneSurface(
            {ellipseCurveLoopTag}, 2);

        // Synchronize the model
        gmsh::model::geo::synchronize();

        gmsh::model::addPhysicalGroup(2, {1}, 1, "Matrix");
        gmsh::model::addPhysicalGroup(2, {2}, 2, "Inclusion");

        // Set mesh options for second-order elements
        gmsh::option::setNumber("Mesh.ElementOrder", 2);
        // serendipity
        gmsh::option::setNumber("Mesh.SecondOrderIncomplete", 1);

        gmsh::option::setNumber("Mesh.RecombineAll", 1);

        // Set mesh algorithm
        gmsh::option::setNumber("Mesh.Algorithm", 8);

        // Generate mesh
        gmsh::model::mesh::generate(2);

        // Save mesh to file
        gmsh::write("rectangle_with_hole.msh");
        gmsh::write("rectangle_with_hole.inp");

        // Retrieve the node coordinates
        std::vector<size_t> nodeTags;
        std::vector<double> parametricCoord;
        gmsh::model::mesh::getNodes(nodeTags, nodeCoord, parametricCoord, -1,
                                    -1);

        // Retrieve the element nodes
        std::vector<size_t> elementTags;
        int elementType =
            gmsh::model::mesh::getElementType("Quadrangle", 2, isSerendipity);
        gmsh::model::mesh::getElementsByType(elementType, elementTags,
                                             elementNodeTags);
        // gmsh::fltk::run();
    } catch (const std::exception& e) {
        std::cerr << e.what();
        return -1;
    }
    // Finalize the Gmsh library
    gmsh::finalize();

    return 0;
}